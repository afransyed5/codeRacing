package com.lam.coder.uva;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

/**
 * 
 * @author Usuario
 *
 *
[an error occurred while processing this directive]

Last updated on: 05 May 2009 03:42:04 PM

Comment on this volume: People are starting their own contests, new contest volume is needed. Again... many mathematical questions, try problem 10168 to 10181 for example...

No

Problem Name	*	Algorithm	Solved by
10096-10101: TCL Programming Contest (2001/04/07 08:00-12:00)

10100	Longest Match	5.5	DP, LCS	*
10101	Bangla Numbers	5.0	Ad Hoc	*
10102-10106: Sergant Pepper's Lonely Programmers (2001/03/15 12:30-16:30)

10102	The path in the colored field	4.5	Graph	*
10103	Karpovich blocks	*	*	*
10104	Euclid Problem	4.5	Math	*
10105	Polynomial Coefficients	6.5	Math	*
10106	Product	3.5	Math	*
10107-10110: May Day Contest (2001/05/01 12:00-15:00)

10107	What is the Median?	3.0	Math	*
10108	The Mosquito Killer Mosquitos	*	*	*
10109	Solving Systems of Linear Equations	*	*	*
10110	Light, more light	4.0	Math	*
10111-10116: University of Valladolid Local Contest (2001/05/12 08:00-12:00)

10111	Find the Winning Move	5.0	Backtracking	*
10112	Myacm Triangles	5.5	Math, Geometry	*
10113	Exchange Rates	*	Shortest Path, Djikstra	*
10114	Loansome Car Buyer	*	*	*
10115	Automatic Editing	3.5	Ad Hoc	*
10116	Robot Motion	4.0	Graph	*
10117-10122: OIBH Online Programming Contest #1 (2001/05/27 06:00-11:00)

10117	Nice Milk	*	*	*
10118	Free Candies	*	*	*
10119	Farewell, my friend	*	*	*
10120	Gift?!	4.5	DP	*
10121	Legendary Pokemon	*	*	*
10122	Mysterious Mountain	*	*	*
10123-10127: Waterloo and Alberta joint contest (2001/06/02 17:00-20:00)

10123	No Tipping	*	*	*
10124	Subway	*	*	Niaz
10125	Sumsets	4.5	Ad Hoc	*
10126	Zipf's Law	4.5	Ad Hoc	*
10127	Ones	4.5	Math	Niaz
10128-10130: Part of Tech U. of Szczecin Contest (2001/06/08 10:30-15:30)

10128	Queue	*	*	*
10129	Play on Words	5.0	Graph, Euler Path property	*
10130	SuperSale	5.0	DP, 0-1 Knapsack	*
10131-10135: The 'silver wedding' contest (2001/06/29 15:00-19:00)

10131	Is Bigger Smarter?	5.0	DP, LIS	*
10132	File Fragmentation	*	*	*
10133	Audubun's Stormy Arctic Ship	*	*	*
10134	AutoFish	5.0	Simulation	*
10135	Herding Frosh	*	*	*
10136-10142: Summer keep-fit 1 (2001/07/12 7:00-12:00)

10136	Chocolate Chip Cookies	*	*	*
10137	The Trip	4.0	Ad Hoc	Neilor
10138	CDVII	*	*	*
10139	Factovisors	*	*	*
10140	Prime Distance	4.5	Math, Prime Numbers	Zhangkai
10141	Request for Proposal	3.0	Ad Hoc	*
10142	Australian Voting	*	Simulation	*
10143-10148: Summer keep-fit 2 (2001/07/26 14:00-19:00)

10143	Loan	*	*	*
10144	Expression	*	*	*
10145	Lock Manager	*	*	*
10146	Dictionary	*	*	*
10147	Highways	5.0	Graph, MST	*
10148	Advertisement	*	*	*
10149-10156: Summer keep-fit 3 (2001/08/16 21:00-3:00+1)

10149	Yahtzee	*	*	*
10150	Doublets	*	*	*
10151	Spaghetti	*	*	*
10152	ShellSort	4.0	Sorting	*
10153	New Horizons	*	*	*
10154	Weights and Measures	5.0	DP, LIS?	*
10155	Green Eggs and Ham	*	*	*
10156	Sala-ma-Sond, A Nice Little Pond	*	*	*
10157-10160: Lazy Summer Bulgarian Prog Contest (2001/08/25 10:00-14:00)

10157	Expressions	*	*	*
10158	War	*	*	*
10159	Star	*	*	*
10160	Servicing Stations	*	*	*
10161-10167: Randy Game Programming Contest (2001/08/11 11:00-15:00)

10161	Ant on a Chessboard	3.0	Ad Hoc	Arif
10162	Last Digit	5.5	Math	Zhangkai
10163	Storage Keepers	*	*	*
10164	Number Game	5.0	Backtracking, DP	William
10165	Stone Game	5.0	Ad Hoc	*
10166	Travel	*	*	*
10167	Birthday Cake	*	*	*
10168-10181: Shahriar Manzoor Math Contest (2001/09/01 7:30-15:30)

10168	Summation of Four Primes	5.5	Math, Prime Number	*
10169	Urn-ball Probabilities !	*	*	*
10170	Servicing Stations	*	*	*
10171	Meeting Prof. Miguel	5.0	Graph, Floyd Warshall	*
10172	The Lonesome Cargo Distributor	*	*	*
10173	Smallest Bounding Rectangle	*	*	*
10174	Couple-Bachelor-Spinster Numbers.	*	*	*
10175	Sphere	*	*	*
10176	Ocean Deep! Make it shallow!!	4.5	Math, Modulo	*
10177	(2/3/4)-D Sqr/Rects/Cubes/Boxes?	*	*	*
10178	Count the Faces.	*	*	*
10179	Irreducible Basic Fractions	5.5	Math	*
10180	Rope Crisis in Ropeland!	*	*	*
10181	15-Puzzle Problem	*	*	*
10182-10187: Xylophone's Dessert (2001/09/14 6:00-10:00)

10182	Bee Maja	4.0	Ad Hoc	*
10183	How Many Fibs?	4.5	Math, Big Integer, Fibonacci	*
10184	Equidistance	*	*	*
10185	Phylogenetic Trees Inherited	*	*	*
10186	Euro Cup 2000	*	*	*
10187	From Dusk Till Dawn	*	*	*
10188-10193: U. do Brasil (UFRJ) Internal warm up (2001/09/28 16:00-19:00)

10188	Automated Judge Script	4.0	String	*
10189	Minesweeper	3.5	Ad Hoc	*
10190	Divide, But Not Quite Conquer!	4.0	Math	*
10191	Longest Nap	4.0	Ad Hoc	*
10192	Vacation	5.0	DP, LCS	*
10193	All You Need Is Love	4.0	Ad Hoc	Arif
10194-10201: U. do Brasil (UFRJ) Internal Contest (2001/10/06 14:00-19:30)

10194	Football (aka Soccer)	5.0	Sorting	*
10195	The Knights Of The Round Table	3.5	Math	*
10196	Check The Check	*	*	*
10197	Learning Portuguese	4.0	Simulation	*
10198	Counting	*	*	*
10199	Tourist Guide	*	*	*
Total hints in this volume: 43

10100 - Longest Match

This is another LCS-DP problem. But this time, instead of characters, the matching is based on words. Refer to my Dynamic Programming page.

10101 - Bangla Numbers

Even though I didn't understand Bangla number system, it seems that the key idea is to read 2 digits by 2 digits from rightmost (minus two digits) except for 1 digit for shata.

Start from the rightmost digit minus two digits, just cycle from shata read 1 digit, hajar, read 2 digits, lakh, read 2 digits, kuti, read another 2 digits, and go back to shata again. So, 45897458973958 will be transformed into something like this 45 89 7 45 89 73 9 58.

10102 - The path in the colored field

In this problem, we will be playing with minimum and maximum...

First, calculate the cost of reaching from any 1 to any 3,
Quick formula: Abs(1.x - 3.x) + Abs (1.y - 3.y).
Then find the minimum for every 1 in the table.
At last, find the maximum of all this numbers.

10104 - Euclid Problem

Search the Net (via google) for this information. "Extended Euclid", use then simply use the formula given. =)

10105 - Polynomial coefficients (By: Maciej Ligenja)



The only component in which xk is in n(k) power is: 
, because (x1+..+xk-1)n-n(k) does not contain xk.



And again the only component which contains xk in n(k) power and xk-1 in n(k-1) power is:

, and so onâ€¦

The last stage is:

 

We have a coefficient but in a very ugly form.
We know: n=n(1)+n(2)+..+n(k).
So:



Our coefficient becomes:

 

10106 - Product

A good problem to test your elementary school mathematic =). Just simulate your elementary school mathematic (use String as your data structure)

10107 - What is the Median?

Another elementary school mathematic =). Just simulate your elementary school mathematic.

10110 - Light, more light

Points to ponder:

1. You only have to care about the last bulb, default state of last bulb is OFF
2. Every i'th walk, only bulbs which serial divisible by i will be toggled
3. Let's examine the last bulb (bulb "n"), all "i" which can divide "n" are factors of "n".
4. See this example: n=36, factors: 1,2,3,4,6,6,9,12,18,36
5. Walk no 1 will toggle last bulb ON, walk no 2 will toggle it OFF, 3->ON, 4->OFF,
    6->ON, 9->OFF, 12->ON, 18->OFF,36->ON
6. See this pattern like this: walk 1 paired with walk "n", walk 2 paired with walk "n-1",
    walk 3 paired with walk "n-3", and so on until walk sqrt(n)
7. In each pairs, if one element toggle last bulb ON, then the other will turn it OFF.
8. Since the default state of last bulb is OFF, then to determine the final state of this bulb,
    you only have to check whether sqrt(n) is an INTEGER or not.
9. If sqrt(n) is integer, then we can find integer x such that x*x=n.
    Walk no "x" will turn the last bulb ON (see example with n=36).

10111 - Find the Winning Move

This problem is just a simulation using backtracking.

You are given an incomplete 4x4 tic-tac-toe board. Currently it is x's turn and asked whether player 'x' can make a forced win. There is no direct formula here... just try from top left (0,0) to bottom right (4,4), try inserting 'x' in this coordinate and recursively check whether 'o' can't do anything to stop x from winning (simulate using backtrack).

Btw this hint may help: if you only have 2'x's and 2'o's (start of the game), there is no winning move... (first sample input)

10112 - Myacm Triangles

Have you solved 478? You can use the formula of knowing whether a point is inside a triangle here. However, this problem is quite complex and floating point related... so be careful.

10113 - Exchange Rates

Dynamic shortest path problem. You know the 'edges' (exchange rate) dynamically. My brother's solution use Djikstra algorithm to find the lowest exchange rate dynamically as new data are materialized.

10115 - Automatic Editing

Simply do what they want.

10116 - Robot Motion

Read the input into 2 dimensional array, start from corner, and simulate the movement. Mark your path and count your path length along the way. If you get outside the grid, then output "<total path length> to exit.". If you encounter marked cell, this means you encounter a cycle. Use your path counter to output the desired values.

10120 - Gift?!

A DP problem. Frank start from left bank and at iteration i, Frank can only jump 2*i-1 meters

Base case: Initially at iteration 1, Frank can jump 1 meter.

Recursive case: From all stone j that Frank can reach at iteration i, then stone[j-2*i-1] and stone[j+2*i+1] also reachable provided that they doesn't fall outside the range [1..N].

Just check whether stone[M] (where the gift is located) is ever reached... Stop the algorithm if no more stones can be reached... (algorithm will definitely terminate because jump length is always increases, it will at one time jump outside range [1..N]).

Now, since N can be very big (up to 10^6), we need to speed up the algorithm by using a special case that when N >= 49, no matter where frog Funny put the gift, Frank will be able to reach it. Proof by induction:

if at N = i, all stones will be reachable then at N = i+1, all stones will always be reachable too because at that time, whatever your jump length is, we can always arrive from any of stone [1..i] to reach stone i+1. This special index happens to be 49 in this case...

10124 - Subway (by: Niaz Morshed Chowdhury)

Let's have some critical calculation.

D - the distance between stations, in metres
M - the maximum allowable speed of the train, in metres/sec
A - the maximum absolute acceleration of the train, in metres/sec2
J - the maximum absolute jerk, in metres/sec3

jtimeaccellimit = A/J
jtimespeedlimit = sqrt(M/J)
jtimedistlimit = exp(log(D/2/J)/3)
jtime = jtimeaccellimit

Now...

if jtimespeedlimit < jtime 
  then jtime = jtimespeedlimit
if jtimedistlimit < jtime
  then jtime = jtimedistlimit

atime = (M - J*pow(jtime,2))/A

a = 0.5*A
b = A*jtime + 0.5*J*pow(jtime,2)
c = J * pow(jtime,3) - D/2
r = (-b + sqrt(b*b - 4*a*c))/2/a

if r < atime
  then atime = r

dist = J * pow(jtime,3) + 0.5*J*pow(jtime,2)*atime + 0.5*A * pow(atime,2) + A * atime*jtime
out_put = [4*jtime+2*atime+2*(D/2-dist)/M]

10125 - Sumsets

Simply use O(n^4) algorithm, a 4-nested for loops. Note: my program is currently slow in problem 10125 rank list :-(, to improve the running time, you might want to apply Dynamic Programming.

10126 - Zipf's Law

You only have to be very careful in tokenizing the input. Get the input line by line, tokenize them into words, put them to a very big array of words, then sort them, and finally count their frequencies. If the frequency equal to "n", print them.

10127 - Ones (by: Niaz Morshed Chowdhury)

This is a very easy but tricky problem. If you want to calculate the sequence of one by increasing ONE, then two thing can be happened.

1) If your data type is even long double (in C it is the highest data type), it can not hold the sequence and because of overflow you will get WA.
2) If your data type is string then you will get "time limit exceeded". To avoid these problems we need to follow a trick here.

The Algorithm

input (it will be the input of the problem)  
N=1 
one=1 (in this variable finally we get how many one will be in the sequence) 

loop until we find the desired answer {
  if N < input
    append a '1'.  (this the way -> N=N*10+1)
    one = one + 1 
  k = N mod input  ( k is a variable )
  do this until k = 0, otherwise N = k and repeat everything
}

Example

Let the input is 3 
At first N = 1 and one  = 1

Now,
3 | 1 | but here N < input so, append a '1'
one = one + 1 = 2
3 | 11| 3
     9
   -----
     2
Now, k = 2, so, N=k;
again,

3 | 2 | but here N < input so append a '1'
one = one + 1 = 3

3 | 21| 7
    21
  -----
     x

So the output is variable 'one' which contains the value 3

Basically, this problem is a reverse version of dividing a series of '1's with N. In the example above. The step by step of dividing "111" with "3" is like this:

3 |111| 37
    9   => the same '9' that we see above
  -----
    21
    21  => the same '21' that we see above
   ----
     x

So, basically we just simulate this division but without spanning out the actual string of '1's.

10129 - Play on Words

This problem can be solved using Euler Path property. Read my programming-graph section.

10130 - SuperSale

This problem is a 0-1 Knapsack problem solvable using Dynamic Programming. Note: Top-down DP may be faster for 0-1 Knapsack problem since most likely not all possible states are visited.

10131 - Is Bigger Smarter?

This problem can be categorized as 2-constraints Longest Increasing Subsequence (LIS). First, sort the elephants based on their decreasing IQ, then apply LIS based on their increasing weight to these elephants. You got the answer. This problem is VERY SIMILAR to problem 10154.

10134 - Auto Fish

This problem is actually just a tedious... error prone... simulation problem. Please read the constraints in the problem description properly... That's all that I can tell you...

10137 - The Trip (by: Neilor)

The problem with this problem may be related to precision error. Here is solution by Neilor:

double highx = (int)((total/n+0.0099)*100);
double lowx = (int)((total/n)*100);
highx /= 100;
lowx /= 100;
Where total is the total sum of the money and n is the number of students.

Then, test each student money if is > than highx or < than lowx, accumulate (student[i]-highx) or (lowx-students[i]), respectively.
Then, output the variable that have the bigger value.

10140 - Prime Distance (by: Zhang Kaicheng)
 */

public class TheTrip {

	public double find(double[] data) {
		return this.equalize(this.average(data), data);
	}

	private double average(double[] data) {
		double t = 0;

		for (double d : data) {
			t += d;
		}
		
		t = t / data.length;
		
		t = (double)Math.round(t * 100) / 100;
//		t = Math.floor(t * 100) / 100;
		
		return t;
	}

	private double equalize(double average, double[] data) {
		double positive = 0;
		double negative = 0;

		for (double d : data) {
			if (d > average) {
				positive += Math.abs(d - average);
			} else {
				negative += Math.abs(d - average);
			}
		}

		double t = positive > negative ? negative : positive;

		int i = (int) ( t * 100);
		t = ((double) i) / 100;
		return t;
	}

	public static void main(String[] args) throws IOException {
		MyScanner scanner = new MyScanner();
		PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));

		TheTrip main = new TheTrip();

		int n = scanner.nextInt();
		String string = scanner.next();

		out.println(n);

		scanner.reader.close();
		out.close();
	}

	// -----------MyScanner class for faster input----------
	public static class MyScanner {
		BufferedReader	reader;

		public MyScanner() {
			this.reader = new BufferedReader(new InputStreamReader(System.in));
		}

		public void close() throws IOException {
			this.reader.close();
		}

		int nextInt() {
			return Integer.parseInt(this.next());
		}

		long nextLong() {
			return Long.parseLong(this.next());
		}

		double nextDouble() {
			return Double.parseDouble(this.next());
		}

		String next() {
			String str = "";
			try {
				str = this.reader.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}

	}
}
